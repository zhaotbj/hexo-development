<!DOCTYPE html>
<html lang=>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content>
  <meta name="keywords" content>
  
    <link rel="icon" href="/favicon.ico">
  
    
  <title>promise是什么 | 博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class="logo" href="/">
      <span>博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id="post">
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>promise是什么</h1>
          <div class="post-meta">
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2019/03/01</time>
            
            
          </div>
          <h2 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h2><blockquote>
<p>promise是什么</p>
</blockquote>
<p>官网解释 promise 表示一个异步操作的最终结果。</p>
<p>翻译  ==可以将promise理解为一个状态机==，它存在三种不同的状态，并在某一时刻只能有一种状态</p>
<ul>
<li>pending 表示还在执行</li>
<li>resolved 执行成功</li>
<li>rejected 执行失败</li>
</ul>
<p>一个promise是对一个异步操作的封装，异步操作有等待完成、成功和失败三种可能的结果，对应了promise的三种状态。</p>
<p>promise的状态只能有pending转换位resolved或者pending转换为rejected，一旦状态转化完成就无法再改变。</p>
<p>假设我们用promise封了一个异步操作，那么当它被创建的时候就处于pending状态，当异步操作成功完成时，<br>我们将状态转换为resolved，如果执行中出现错误，将状态转换为rejected。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">  <span class="keyword">if</span>()&#123;</span><br><span class="line">    <span class="comment">/*异步操作成功 */</span></span><br><span class="line">    resolve(value)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="使用then方法获取结果"><a href="#使用then方法获取结果" class="headerlink" title="使用then方法获取结果"></a>使用then方法获取结果</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile_promise</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(path, <span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(data)&#123;</span><br><span class="line">        resolve(data)</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result=readFile_promise(<span class="string">'./1.txt'</span>)</span><br><span class="line">result.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, value)</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//failure</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failure'</span>,error)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 将一个异步函数封装成promise，只要在回调函数中针对不同的返回结果调用resolve或者reject方法。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// resolve函数会在异步操作成功完成时被调用，并将异步操作的返回值作为参数传递到外部。</span></span><br><span class="line"><span class="comment">// reject是在异步操作出现异常时被调用，会将错误信息作为参数传递出去。</span></span><br></pre></td></tr></table></figure>
<h5 id="then方法的返回值"><a href="#then方法的返回值" class="headerlink" title="then方法的返回值"></a>then方法的返回值</h5><p>then方法总是返回一个新的promise对象，多次调用then方法，默认返回一个一个空的promise对象<br>使用return来来返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise=readFile_promise(<span class="string">'./foo.txt'</span>)</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//success</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'success'</span>, value) <span class="comment">// foo</span></span><br><span class="line">  <span class="keyword">return</span> readFile_promise(<span class="string">'./bar.txt'</span>)</span><br><span class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//failure</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'failure'</span>,error)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'then'</span>, value) <span class="comment">// bar</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="promise的执行"><a href="#promise的执行" class="headerlink" title="promise的执行"></a>promise的执行</h5><ul>
<li>虽然我们是通过then方法来获取promise的结果，但是promise是当then方法调用之后才执行吗？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise=<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'begin'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  promise.then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">5000</span>)</span><br><span class="line"><span class="comment">// 开始begin 5s后end</span></span><br><span class="line"><span class="comment">// 运行顺序是，当promise从被创建的那一刻起就开始执行了，then方法只是提供了访问promise状态的接口，与promise的执行无关。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="promise-常用的api"><a href="#promise-常用的api" class="headerlink" title="promise 常用的api"></a>promise 常用的api</h5><ul>
<li>resolved </li>
<li>rejected</li>
<li>all</li>
<li>race 方法接收一个promise数组作为参数并返回一个新的promise，数组中的promise会同时开始执行，race返回的promise的状态有数组中率先执行完毕的promise的状态决定</li>
<li>catch 执行出错可以使用throw关键字抛出错误，并使用catch方法进行捕获<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 如果有多个promise需要执行，可以使用promise.all()</span></span><br><span class="line"><span class="comment">// 方法统一声明，改方法可以将多个promise对象包装成一个promise</span></span><br><span class="line"><span class="comment">// 该方法接收一个数组作为参数，数据的元素如果不是promise对象，则回先调用resolve方法转换。</span></span><br><span class="line"><span class="comment">//  如果中间有一个promise状态是reject，那么转换后的promise也会变成reject，并且将错误信息传给catch方法</span></span><br><span class="line"><span class="keyword">var</span> promises=[<span class="string">'foo.txt'</span>,<span class="string">'bar.txt'</span>,<span class="string">'baz.txt'</span>]</span><br><span class="line">promises.map(<span class="function"><span class="keyword">function</span>(<span class="params">path</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// console.log(path)</span></span><br><span class="line">  <span class="keyword">return</span> readFile_promise(path)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises).then(<span class="function"><span class="keyword">function</span>(<span class="params">results</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(results) <span class="comment">// [ 'foo.txt', 'bar.txt', 'baz.txt' ] 顺序排列的</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="使用promise组织异步代码"><a href="#使用promise组织异步代码" class="headerlink" title="使用promise组织异步代码"></a>使用promise组织异步代码</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子； 有三个文本文件需要顺序读取</span></span><br><span class="line"><span class="keyword">var</span> lists=[<span class="string">'foo.txt'</span>,<span class="string">'bar.txt'</span>,<span class="string">'baz.txt'</span>]</span><br><span class="line"><span class="keyword">var</span> count=<span class="number">0</span>;</span><br><span class="line">readFile_promise(<span class="string">'foo.txt'</span>).then(readCB).then(readCB).then(readCB);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readCB</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// foo bar baz</span></span><br><span class="line">  <span class="keyword">if</span>(++count&gt;<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> readFile_promise(lists[count])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h3><p>await关键字后面往往是一个promise，如果不是就隐式调用promise.resolve来转换成一个promise。<br>await 等待后面的promise执行完成再进行下一步操作。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile=<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result1=<span class="keyword">await</span> readFile_promise(<span class="string">'./foo.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(result1.toString()) <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line">asyncReadFile()</span><br></pre></td></tr></table></figure></p>
<h5 id="async返回值"><a href="#async返回值" class="headerlink" title="async返回值"></a>async返回值</h5><p>async函数总是会返回一个promise对象，如果return关键字后面不是一个promise，那么默认<br>调用promise。resolve方法进行转换。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello Node'</span></span><br><span class="line">&#125;</span><br><span class="line">asyncFunc().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// hello Node</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="async函数的执行过程"><a href="#async函数的执行过程" class="headerlink" title="async函数的执行过程"></a>async函数的执行过程</h5><ol>
<li>在async函数开始执行的时候回自动生成一个promise对象。</li>
<li>当方法体开始执行后，如果遇到return关键字或者throw关键字，执行会立刻退出，<br>如果遇到await关键字则回暂停执行 await后面的异步操作结束后会恢复执行</li>
<li>执行完毕，返回一个promise<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'begin'</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'hello Node'</span></span><br><span class="line">&#125;</span><br><span class="line">asyncFunc().then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// hello Node</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'end'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// begin </span></span><br><span class="line"><span class="comment">// hello </span></span><br><span class="line"><span class="comment">// end</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="await"><a href="#await" class="headerlink" title="await"></a>await</h5><p>await 操作符的结果是由其后面promise对象的操作结果来决定的，如果后面promise对象变为resolved,<br>await操作符发返回的值就是resolve的值；如果promise对象的状态变成rejected，那么await也会抛出reject的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result=<span class="keyword">await</span> readFile_promise(<span class="string">'./foo.txt'</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">// foo</span></span><br><span class="line">&#125;</span><br><span class="line">readFile()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">readFile_promise(<span class="string">'foo.txt'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data) <span class="comment">// foo</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h5 id="await于并行"><a href="#await于并行" class="headerlink" title="await于并行"></a>await于并行</h5><p>await会等待后面的promise完成后再采取下一步动作，这意味着当多个await操作时，程序会便成完全的<br>串行操作。</p>
<p>当异步操作之间不存在依赖关系时，可以使用promise.all来实现并行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [result1, result2]=<span class="keyword">await</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    readFile_promise(<span class="string">'./foo.txt'</span>),</span><br><span class="line">    readFile_promise(<span class="string">'./bar.txt'</span>)</span><br><span class="line">  ])</span><br><span class="line">  <span class="built_in">console</span>.log(result1, result2) <span class="comment">// foo bar</span></span><br><span class="line">&#125;</span><br><span class="line">readFile()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all([</span><br><span class="line">    readFile_promise(<span class="string">'./foo.txt'</span>),</span><br><span class="line">    readFile_promise(<span class="string">'./baz.txt'</span>)</span><br><span class="line">  ]).then(<span class="function">(<span class="params">result</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result) <span class="comment">// [ 'foo', 'baz' ]</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">readFile()</span><br></pre></td></tr></table></figure></p>
<h3 id="await-总结"><a href="#await-总结" class="headerlink" title="await 总结"></a>await 总结</h3><blockquote>
<p>await关键字使用的一些关键点</p>
</blockquote>
<ul>
<li>await关键字必须位于async函数内部</li>
<li>await关键字后面需要是一个promise对象（不是的话就调用了resolve转换的）</li>
<li>await关键字的返回结果就是在其后面promise执行的结果，可能是resolved或者rejected的值</li>
<li>不能在普通箭头函数中使用await关键字，需要在箭头函数前面加上async关键字。</li>
<li>await用来串行地执行异步操作，想实现并行使用promise.all</li>
</ul>
<h3 id="async函数-的缺点"><a href="#async函数-的缺点" class="headerlink" title="async函数 的缺点"></a>async函数 的缺点</h3><ul>
<li>假设我们有很多层的方法调用，最底层的异步操作被封装成了async方法，那么该函数的所有上层方法可能都要变成async方法。</li>
<li></li>
</ul>

        </section>
    </article>
    
        <!-- disqus 评论框 start -->
        <div class="comment">
            <div id="disqus_thread" class="disqus-thread">
              <i>Loading comments box needs to over the wall</i>
            </div>
        </div>
        <!-- disqus 评论框 end -->
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#promise"><span class="toc-number">1.</span> <span class="toc-text">promise</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用then方法获取结果"><span class="toc-number">1.0.0.1.</span> <span class="toc-text">使用then方法获取结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#then方法的返回值"><span class="toc-number">1.0.0.2.</span> <span class="toc-text">then方法的返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#promise的执行"><span class="toc-number">1.0.0.3.</span> <span class="toc-text">promise的执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#promise-常用的api"><span class="toc-number">1.0.0.4.</span> <span class="toc-text">promise 常用的api</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用promise组织异步代码"><span class="toc-number">1.0.0.5.</span> <span class="toc-text">使用promise组织异步代码</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#async-await"><span class="toc-number">1.1.</span> <span class="toc-text">async/await</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#async返回值"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">async返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#async函数的执行过程"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">async函数的执行过程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">await</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await于并行"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">await于并行</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await-总结"><span class="toc-number">1.2.</span> <span class="toc-text">await 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async函数-的缺点"><span class="toc-number">1.3.</span> <span class="toc-text">async函数 的缺点</span></a></li>
        </div>
    </div>
    
  </aside>
</main>

<!-- disqus 公共JS代码 -->
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = "lewis-blog";
  var disqus_identifier = "https://zhaotbj.github.io/2019/03/01/";
  var disqus_url = "https://zhaotbj.github.io/2019/03/01/";

  isAgent(getDisqus)

  // determine user agent in China
  function isAgent(cb) {
    var url = '//graph.facebook.com/feed?callback=h';
    var xhr = new XMLHttpRequest();
    var called = false;
    xhr.open('GET', url);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
      called = true;
      cb(true);
      }
    };
    xhr.send();
    // timeout 1s, this facebook API is very fast.
    setTimeout(function() {
      if (!called) {
      xhr.abort();
      cb(false)
      }
    }, 1000);
  }

  function getDisqus(isAgent) {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; 
    dsq.async = true
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq)
  }
</script>
<!-- disqus 公共JS代码 end -->



  <footer>
  <div class="copyright">
    <div>
      &copy; 2019 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
