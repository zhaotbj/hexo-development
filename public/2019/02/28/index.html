<!DOCTYPE html>
<html lang=>
  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content>
  <meta name="keywords" content>
  
    <link rel="icon" href="/favicon.ico">
  
    
  <title>ES6 数组&amp;对象&amp;类 | 博客</title>
  <link rel="stylesheet" href="/style.css">
  <link rel="stylesheet" href="/lib/jquery.fancybox.min.css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
</head>

<body>
  <header>
  <div class="header-container">
    <a class="logo" href="/">
      <span>博客</span>
    </a>
    <ul class="right-header">
      
        <li class="nav-item">
          
            <a href="/" class="item-link">首页</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/about" class="item-link">关于</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/archives" class="item-link">归档</a>
          
        </li>
      
        <li class="nav-item">
          
            <a href="/tags" class="item-link">标签</a>
          
        </li>
      
    </ul>
  </div>
</header>

  <main id="post">
  <div class="content">
    <article>
        <section class="content markdown-body">
          <h1>ES6 数组&amp;对象&amp;类</h1>
          <div class="post-meta">
            <i class="fa fa-calendar" aria-hidden="true"></i> <time>2019/02/28</time>
            
            
          </div>
          <h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><ul>
<li>var 可以重复定义、不能限制修改、没有块级作用域</li>
<li>let 不能重复定义， 变量，块级作用域</li>
<li>const 不能重复定义， 常量，块级作用域<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重复申明 变量提升</span></span><br><span class="line"><span class="keyword">var</span>命令会发生”变量提升“现象</span><br><span class="line"><span class="keyword">let</span>不允许在相同作用域内，重复声明同一个变量； 变量不提升</span><br><span class="line"><span class="keyword">const</span> 的变量不可以被修改，也不能重复申明</span><br><span class="line">使用<span class="keyword">const</span>的对象可以修改，因为<span class="keyword">const</span>内部是依靠指针来判断一个对象是否被修改</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h5 id="数组实例的-find-和-findIndex"><a href="#数组实例的-find-和-findIndex" class="headerlink" title="数组实例的 find() 和 findIndex()"></a>数组实例的 find() 和 findIndex()</h5><p> 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，<br> 所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。<br> 如果没有符合条件的成员，则返回undefined。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">-4</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&lt;<span class="number">0</span></span><br><span class="line">&#125;)<span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>fill()方法<br>Fill方法用给一个给定的值来填充数组，通常用来初始化一个新建的array对象<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// [ &lt;5 empty items&gt; ]</span></span><br><span class="line">a.fill(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">//[ 0, 0, 0, 0, 0 ]</span></span><br><span class="line"><span class="comment">// ES5方法实现</span></span><br><span class="line"><span class="comment">// 需要借助apply和map方法</span></span><br><span class="line"><span class="keyword">var</span> array = <span class="built_in">Array</span>.apply(<span class="literal">null</span>, <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span>))</span><br><span class="line">.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(array) <span class="comment">// [ 0, 0, 0, 0, 0 ]</span></span><br><span class="line"><span class="comment">// ES6方式实现</span></span><br><span class="line"><span class="keyword">const</span> array = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>).fill(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="from方法"><a href="#from方法" class="headerlink" title="from方法"></a>from方法</h5><blockquote>
<p>Array.from([array-like])=&gt;[x,x,x]</p>
</blockquote>
<p>用于将一个array-like object转换为数组</p>
<p>什么是array-like?</p>
<p>例子：js中的参数对象arguments就是一个array-like object我们可以通过[]来访问其中的元素，<br>也可以使用length。但是不能使用array对象的方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建一个array-like object</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;<span class="number">10</span>) &#123;</span><br><span class="line">  a[i]=i*i</span><br><span class="line">  i++</span><br><span class="line">&#125;</span><br><span class="line">a.length = i </span><br><span class="line"><span class="comment">// console.log(a)</span></span><br><span class="line"><span class="comment">/* &#123; '0': 0,</span></span><br><span class="line"><span class="comment">  '1': 1,</span></span><br><span class="line"><span class="comment">  '2': 4,</span></span><br><span class="line"><span class="comment">  '3': 9,</span></span><br><span class="line"><span class="comment">  '4': 16,</span></span><br><span class="line"><span class="comment">  '5': 25,</span></span><br><span class="line"><span class="comment">  '6': 36,</span></span><br><span class="line"><span class="comment">  '7': 49,</span></span><br><span class="line"><span class="comment">  '8': 64,</span></span><br><span class="line"><span class="comment">  '9': 81,</span></span><br><span class="line"><span class="comment">  length: 10 &#125; */</span></span><br><span class="line">  <span class="comment">// 在es5中可以使用array.prototype.slice方法来将array-like对象转换成真正的数组，</span></span><br><span class="line">  <span class="comment">// 不便的是如果要转换一个现有的object</span></span><br><span class="line">  <span class="comment">// 通常还要调用call()方法，否则返回的是一个空数组</span></span><br><span class="line">  <span class="comment">// ES5 </span></span><br><span class="line"><span class="keyword">var</span> al = <span class="built_in">Array</span>.prototype.slice.call(a); <span class="comment">// 需要增加call()方法</span></span><br><span class="line">  al.push(<span class="number">10</span>) </span><br><span class="line">  <span class="built_in">console</span>.log(al) <span class="comment">// [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 10 ]</span></span><br><span class="line"><span class="comment">// ES6  </span></span><br><span class="line"><span class="keyword">var</span> a2= <span class="built_in">Array</span>.from(a); <span class="comment">// form方法不是定义在prototype上的</span></span><br><span class="line">a2.push(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">console</span>.log(a2) <span class="comment">// [ 0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 10 ]</span></span><br></pre></td></tr></table></figure>
<h5 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h5><p>ES6提供三个新的方法 entries, keys 和values用于遍历数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区别</span></span><br><span class="line"><span class="comment">// keys是对键名的遍历 values是对键值的遍历 entries是对键值对的遍历</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> a.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> a.values()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i) <span class="comment">// a b c</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> a.entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// [ 0, 'a' ]</span></span><br><span class="line"><span class="comment">// [ 1, 'b' ]</span></span><br><span class="line"><span class="comment">// [ 2, 'c' ]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h5 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数的默认值</span></span><br><span class="line"><span class="comment">// 如果在参数重使用了默认值，那么就不能再方法体内再使用let关键字申明同名的变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greed</span>(<span class="params">x=<span class="string">'Hello'</span>, y=<span class="string">'Node'</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y)</span><br><span class="line">&#125;</span><br><span class="line">greed() <span class="comment">// Hello Node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// spread运算符</span></span><br><span class="line"><span class="comment">// 合并数组，在ES5中通常调用concat方法来实现</span></span><br><span class="line"><span class="keyword">var</span> arr =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> arr2=[<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log([...arr, ...arr2]) <span class="comment">// [ 1, 2, 3, 4, 5 ]</span></span><br><span class="line"><span class="comment">// 将字符串转换为数组</span></span><br><span class="line"><span class="keyword">var</span> name=[...<span class="string">'learing'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// [ 'l', 'e', 'a', 'r', 'i', 'n', 'g' ]</span></span><br><span class="line"><span class="comment">// ...也可以作为函数的参数,表示该函数有多个参数,也可以在函数调用时使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">x,y,z</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y+z</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">func(...args) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><blockquote>
<p>优点</p>
</blockquote>
<p>箭头函数 可以修复 this作用域</p>
<p> setTimeout中匿名函数的this的指向，node和浏览器是不同的<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匿名函数中的this</span></span><br><span class="line"><span class="comment">/* var obj=&#123;&#125;</span></span><br><span class="line"><span class="comment">obj.func = function() &#123;</span></span><br><span class="line"><span class="comment">  console.log(this)</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浏览器中是Windows 在node中输出的是一个timeout对象</span></span><br><span class="line"><span class="comment">// 使用箭头函数后，this的指向和foo函数内部相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数自动绑定this, 实际上匿名函数函数内部没有定义this,仅是引用外面一层的this而已。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 弄清匿名函数内部的this指向</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=<span class="string">'lear'</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name--'</span>, <span class="keyword">this</span>.name) <span class="comment">// lear</span></span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数本身没有定义this,在箭头函数内部使用this关键字时，</span></span><br><span class="line"><span class="comment">// 它开始在代码定义的位置向上找，直到遇见第一个this,</span></span><br><span class="line"><span class="comment">// 这带来了很大的便利，但是在构造函数中会出现问题</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name =<span class="string">'lear'</span></span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.greet = <span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.name) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person =<span class="keyword">new</span> Person()</span><br><span class="line">person.greet()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现undefined是因为 箭头函数绑定了上一层的环境，就是全局环境中的this</span></span><br><span class="line"><span class="comment">// 这段代码在浏览器中运行时this是Windows</span></span><br><span class="line"><span class="comment">// 不建议在构造函数中使用箭头函数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Set-amp-Map"><a href="#Set-amp-Map" class="headerlink" title="Set&amp;Map"></a>Set&amp;Map</h3><h5 id="Set-和-WeakSet"><a href="#Set-和-WeakSet" class="headerlink" title="Set 和 WeakSet"></a>Set 和 WeakSet</h5><p>Set 的实现类似于数组，和普通数组的不同在于Set中不能包含重复的数据</p>
<p>weakSet和set的区别在于weakset的成员只能是对象， weak是虚弱的意思，表示weakset中存储的对象没有被其他对象所引用，其内存空间就会被回收。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set= <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">// 使用够构造函数初始化一个set</span></span><br><span class="line">set.add(<span class="number">6</span>) <span class="comment">//添加  &#123;1,2,3,4,5&#125;是array-like 使用Array.form()转为array</span></span><br><span class="line">set.delete(<span class="number">5</span>) <span class="comment">// 删除</span></span><br><span class="line"><span class="built_in">console</span>.log(set.has(<span class="number">6</span>)) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(set) </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set.clear()  <span class="comment">// 清除所有元素</span></span><br><span class="line"><span class="built_in">console</span>.log(set) <span class="comment">// &#123;&#125;</span></span><br><span class="line">-----</span><br><span class="line"><span class="keyword">var</span> wset =<span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line">wset.add(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;) <span class="comment">//success</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>set的遍历<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> set.keys()) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i) <span class="comment">// 1 2 3</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> set.values()) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i) <span class="comment">//  123</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">of</span> set.entries()) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(i)</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//  [ 1, 1 ]</span></span><br><span class="line"><span class="comment">// [ 2, 2 ]</span></span><br><span class="line"><span class="comment">// [ 3, 3 ]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="Map和weakMap"><a href="#Map和weakMap" class="headerlink" title="Map和weakMap"></a>Map和weakMap</h5><p>Map 表示键值对组成的有序集合<br>有序表现在map的遍历顺序即为插入顺序</p>
<p>weakMap的用法和weakSet相似，作为key的变量必须是个对象，也是弱引用类型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">var</span> map= <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'a'</span>,<span class="number">1</span>], [<span class="string">'b'</span>,<span class="number">2</span>],[obj,<span class="number">3</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">// 3  map的大小</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'a'</span>)) <span class="comment">// true  判断是否存在键值对</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'a'</span>)) <span class="comment">// 获取摸个键值对的值</span></span><br><span class="line">map.set(<span class="string">'d'</span>, <span class="number">4</span>) <span class="comment">// 如果键值不存在，则增加新的键值对，否者覆盖原有的值</span></span><br><span class="line">map.delete(<span class="string">'d'</span>) <span class="comment">// 删除 返回布尔值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">of</span> map.keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// &#123; c: 3 &#125;]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><ul>
<li>新的方法object.assign() </li>
</ul>
<p>该方法将一个对象的属复制到另一个对象上， ==浅拷贝==。</p>
<ul>
<li>对象的遍历 es5使用 for in es6 Object.keys() <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浅拷贝</span></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;<span class="attr">a</span>: &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.assign(&#123;&#125;, obj1)</span><br><span class="line">obj1.a.b=<span class="number">2</span></span><br><span class="line"><span class="comment">// console.log(obj2.a.b) // 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的遍历</span></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">  <span class="string">'name'</span>: <span class="string">'lear'</span>,</span><br><span class="line">  <span class="string">'age'</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">'sex'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.使用for in 遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="comment">// console.log('key', key, obj[key] )</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  2.object.keys() 遍历</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj)) <span class="comment">// [ 'name', 'age', 'sex' ]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类-class"><a href="#类-class" class="headerlink" title="类 class"></a>类 class</h3><h5 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="comment">// 在js中，类的所有实例对象都从同一个原型对象上继承属性</span></span><br><span class="line"><span class="comment">/* function Person (sex, age) &#123;</span></span><br><span class="line"><span class="comment">  this.sex =sex</span></span><br><span class="line"><span class="comment">  this.age= age</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">Person.prototype.getInfo =function()&#123;</span></span><br><span class="line"><span class="comment">  return this.sex+','+this.age</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">var person =new Person('man', '10')</span></span><br><span class="line"><span class="comment">console.log(person.getInfo()) // man,10</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h5 id="ES6-语法糖"><a href="#ES6-语法糖" class="headerlink" title="ES6 语法糖"></a>ES6 语法糖</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 语法糖</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(sex, age)&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=sex</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">  &#125;</span><br><span class="line">  getInfo()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.sex+<span class="string">','</span>+<span class="keyword">this</span>.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person(<span class="string">'female'</span>, <span class="string">'20'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getInfo()) <span class="comment">// female,20</span></span><br></pre></td></tr></table></figure>
<h5 id="属性和构造函数"><a href="#属性和构造函数" class="headerlink" title="属性和构造函数"></a>属性和构造函数</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  属性和构造函数</span></span><br><span class="line"><span class="comment">// class中的属性定义在constructor函数（构造函数）中，构造函数负责类的初始化，</span></span><br><span class="line"><span class="comment">// 包括初始化属性和调用其他类方法等</span></span><br><span class="line"><span class="comment">// 构造函数同样支持默认值参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果申明一个类的时候没有声明构造函数，那么会默认添加一个空的构造函数。</span></span><br><span class="line"><span class="comment">// 构造函数只有在使用关键字new实例化一个对象的时候才会被调用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name="lear", sex='male')&#123;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="string">'lear'</span></span><br><span class="line">    <span class="keyword">this</span>.sex=<span class="string">'male'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name='lear', sex='male')&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.sex=sex</span><br><span class="line">  &#125;</span><br><span class="line">  getInfo()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'name ：'</span>, <span class="keyword">this</span>.name, <span class="string">'sex :'</span>,<span class="keyword">this</span>.sex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> student=<span class="keyword">new</span> Student()</span><br><span class="line"><span class="comment">// console.log(student.getInfo()) // name ： lear sex : male</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法也可以作为属性定义在构造函数中，</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name='lear', sex='male')&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.sex=sex</span><br><span class="line">    <span class="keyword">this</span>.getInfo=<span class="function"><span class="params">()</span>=&gt;</span>&#123; <span class="comment">// 类方法也可以是箭头函数</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'name ：'</span>, <span class="keyword">this</span>.name, <span class="string">'sex :'</span>,<span class="keyword">this</span>.sex)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h5><p>ES5中，类的实现通过<strong>proto</strong>属性来指向构造函数的prototype对象<br>es6中，==getinfo方法和constructor方法虽然看似是定义在类的内部，但实际上还是定义在prototype上，<br>侧面可以看出ES6是对class的实现依旧是基于prototype==<br><code>person.constructor=Person.prototype.constructor</code> // true</p>
<p>对象的<strong>proto</strong>属性指向类的原型</p>
<p>类的本质是构造函数</p>
<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><p>在定义类时如果定义了方法,那么该类的每个实例在初始化时都会有一份该方法的备份。有时候我们不希望一些方法被继承,而是希望作为父类的属性来使用,可以直接通过调用类名调用的方法,即静态方法。</p>
<p>es6中使用static关键字来声明一个静态方法，该方法只能通过类名来直接调用，而不能通过类的实例调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'lear'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.getName() <span class="comment">// lear</span></span><br><span class="line"><span class="keyword">var</span> person=<span class="keyword">new</span> Person()</span><br><span class="line">person.getName() <span class="comment">// error</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// super 关键字调用父类的静态方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'lear'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> getName2() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getName() + <span class="string">', Hi'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Student.getName2()) <span class="comment">// lear, Hi</span></span><br></pre></td></tr></table></figure>
<h4 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h4><ul>
<li>ES6中的继承<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">    <span class="keyword">this</span>.age=age</span><br><span class="line">  &#125;</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name + <span class="string">','</span> +<span class="keyword">this</span>.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1= <span class="keyword">new</span> Person(<span class="string">'zhansan'</span>, <span class="number">18</span>, <span class="string">'男'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p1.getInfo()) <span class="comment">// zhansan,18,男</span></span><br><span class="line"><span class="comment">// 继承person类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name, age, sex)&#123;</span><br><span class="line">    <span class="comment">//super调用了父类的构造函数，并将父类中的属性绑定到子类上。</span></span><br><span class="line">    <span class="comment">//  super可以带参数， 表示那些父类的属性会被继承。</span></span><br><span class="line">    <span class="comment">// 在子类中，super方法必须要调用的，因为在子类本身没有自身的this对象，必须通过super方法拿到父类的this对象，</span></span><br><span class="line">    <span class="comment">// 除了用在子类的构造函数中，super还可以用在类方法中来引用父类的方法。</span></span><br><span class="line">    <span class="keyword">super</span>(name, age)</span><br><span class="line">    <span class="keyword">this</span>.sex=sex</span><br><span class="line">  &#125;</span><br><span class="line">  getInfo() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getInfo()+ <span class="string">'----'</span>+ <span class="keyword">this</span>.sex <span class="comment">// 调用父类的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    <span class="keyword">var</span> info=<span class="keyword">this</span>.getInfo()</span><br><span class="line">    <span class="built_in">console</span>.log(info)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2=<span class="keyword">new</span> Student(<span class="string">'李四'</span>, <span class="number">16</span>, <span class="string">'女'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(p2.getInfo()) <span class="comment">// 李四,16----女</span></span><br><span class="line">p2.print() <span class="comment">// 李四,16----女</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5中的继承</span></span><br><span class="line"><span class="comment">// 我们有一个父类Person,并且在类的内部和原型链上各定义了一个方法：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name</span><br><span class="line">  <span class="keyword">this</span>.age=age</span><br><span class="line">  <span class="keyword">this</span>.greed=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, i am'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getInfo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name+<span class="string">','</span>+<span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改原型链</span></span><br><span class="line"><span class="comment">// 这是最普通的继承方法， 通过将子类的prototype指向父类的实例来实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Student.prototype=<span class="keyword">new</span> Person()</span><br><span class="line">Student.prototype.name=<span class="string">'lear'</span></span><br><span class="line">Student.prototype.age=<span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> stud=<span class="keyword">new</span> Student()</span><br><span class="line">stud.getInfo() <span class="comment">// lear,10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点：在子类构造函数中无法通过传递参数对父类继承的属性值进行修改，只能通过修改prototype的方式进行修改。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name</span><br><span class="line">  <span class="keyword">this</span>.age=age</span><br><span class="line">  <span class="keyword">this</span>.greed=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, i am'</span>, <span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getInfo=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name+<span class="string">','</span>+<span class="keyword">this</span>.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name,age,sex</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">this</span>.name=name</span><br><span class="line">  <span class="keyword">this</span>.age=age</span><br><span class="line">  <span class="keyword">this</span>.sex=sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> stud=<span class="keyword">new</span> Student(<span class="string">'lear'</span>,<span class="number">10</span>,<span class="string">'male'</span>)</span><br><span class="line">stud.greed() <span class="comment">// Hello, i am lear</span></span><br><span class="line">stud.getInfo() <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

        </section>
    </article>
    
        <!-- disqus 评论框 start -->
        <div class="comment">
            <div id="disqus_thread" class="disqus-thread">
              <i>Loading comments box needs to over the wall</i>
            </div>
        </div>
        <!-- disqus 评论框 end -->
    
        
  </div>
  <aside>
    
    <div class="toc-container">
        <h1>目录</h1>
        <div class="content">
            <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#块级作用域"><span class="toc-number">1.</span> <span class="toc-text">块级作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">2.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数组实例的-find-和-findIndex"><span class="toc-number">2.0.1.</span> <span class="toc-text">数组实例的 find() 和 findIndex()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#from方法"><span class="toc-number">2.0.2.</span> <span class="toc-text">from方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#数组的遍历"><span class="toc-number">2.0.3.</span> <span class="toc-text">数组的遍历</span></a></li></ol></li></ol><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-number">3.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#参数的默认值"><span class="toc-number">3.0.1.</span> <span class="toc-text">参数的默认值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#箭头函数"><span class="toc-number">3.0.2.</span> <span class="toc-text">箭头函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-amp-Map"><span class="toc-number">4.</span> <span class="toc-text">Set&amp;Map</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Set-和-WeakSet"><span class="toc-number">4.0.1.</span> <span class="toc-text">Set 和 WeakSet</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Map和weakMap"><span class="toc-number">4.0.2.</span> <span class="toc-text">Map和weakMap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-number">5.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类-class"><span class="toc-number">6.</span> <span class="toc-text">类 class</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ES5"><span class="toc-number">6.0.1.</span> <span class="toc-text">ES5</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ES6-语法糖"><span class="toc-number">6.0.2.</span> <span class="toc-text">ES6 语法糖</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#属性和构造函数"><span class="toc-number">6.0.3.</span> <span class="toc-text">属性和构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类方法"><span class="toc-number">6.0.4.</span> <span class="toc-text">类方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#proto"><span class="toc-number">6.0.5.</span> <span class="toc-text">proto</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#静态方法"><span class="toc-number">6.0.6.</span> <span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类的继承"><span class="toc-number">6.1.</span> <span class="toc-text">类的继承</span></a></li>
        </div>
    </div>
    
  </aside>
</main>

<!-- disqus 公共JS代码 -->
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES * * */
  var disqus_shortname = "lewis-blog";
  var disqus_identifier = "https://zhaotbj.github.io/2019/02/28/";
  var disqus_url = "https://zhaotbj.github.io/2019/02/28/";

  isAgent(getDisqus)

  // determine user agent in China
  function isAgent(cb) {
    var url = '//graph.facebook.com/feed?callback=h';
    var xhr = new XMLHttpRequest();
    var called = false;
    xhr.open('GET', url);
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
      called = true;
      cb(true);
      }
    };
    xhr.send();
    // timeout 1s, this facebook API is very fast.
    setTimeout(function() {
      if (!called) {
      xhr.abort();
      cb(false)
      }
    }, 1000);
  }

  function getDisqus(isAgent) {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; 
    dsq.async = true
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq)
  }
</script>
<!-- disqus 公共JS代码 end -->



  <footer>
  <div class="copyright">
    <div>
      &copy; 2019 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a>&nbsp
    </div>
    <div>
      Theme by <a href="https://github.com/lewis-geek/hexo-theme-Aath" target="_blank">Aath</a>
    </div>
  </div>
</footer>


<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script src="/lib/in-view.min.js"></script>
<script src="/lib/lodash.min.js"></script>
<script>
  var isDown = true
  var oldY = 0
  inView.offset(50)

  document.body.addEventListener('touchstart', function(){});
  
  window.addEventListener('scroll', _.throttle(e => {
    var currentY = window.scrollY
    if((oldY - currentY) < 0) {
      isDown = true
    } else {
      isDown = false
    }
    oldY = currentY
  }, 250))

  $("article img").each(function() {
      var strA = "<a data-fancybox='gallery' href='" + this.src + "'></a>";
      $(this).wrapAll(strA);
  });

  $('.toc-link').each(function() {
      var href = $(this).attr("href");
      
      inView(href).on('exit', () => {
        if (isDown) {
          handleActive(href)
        }
      })

      inView(href).on('enter', () => {
        if (!isDown) {
          handleActive(href)
        }
      })

      this.onclick = function(e) {
        var pos = $(href).offset().top - 10;
        $("html,body").animate({scrollTop: pos}, 300);
        setTimeout(() => {
          handleActive(href)
        }, 350)
        return false
      }
  })

  function handleActive(href) {
    document.querySelectorAll('.toc-link').forEach(elm => {
      elm.classList.remove('active')
    })
    document.querySelector(".toc [href='"+ href +"']").classList.add('active')
  }
</script>
<script src="/lib/jquery.fancybox.min.js"></script>


</body>
</html>
